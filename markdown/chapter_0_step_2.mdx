# Chapter 3: Listing Missions

This is great, so now we know how to read data, manipulate it and return it. We are already able to send inputs to our dApp through the *'handle_advance'* function. But what about the *'handle_inspect'*?

## Inspect
Just like we specialized the advance calls we are gonna to the same for inspect calls. 

Picture an adventurer that wants to check missions available on a tavern in a big city. Now, It does not make sense that the user sends an input and gets the return of this input to list missions, anyone should be able to check available missions right?

For this we can use an inspect call. An HTTP request directly to the node to check it's current state!

It's as easy to check on browser for an URL, like this:
## Input
```url
http://<rollup_server>/list_missions"
```

But there is more! Here we are finally going to understand the other type of output. The **report**

## Reports

Reports are stateless logs, offering a means to record read-only information without changing the state. Primarily used for logging and diagnostic purposes, reports provide valuable insights into the operation and performance of a dApp.

Unlike notices, reports lack any association with proof and are therefore unsuitable for facilitating trustless interactions, such as on-chain processing or convincing independent third parties of dApp outcomes.

Reports can be used both in the advance function to create logs, generally used to treat errors or inside the inspect function to signalize the output. 

## Objective

Your task in this chapter is to modify the *'list_missions'* function that is called inside the `handle_inspect` function to return a list of missions. 

Remember what we seen before: The `handle_inspect` is similar to a `GET` request in the sense that it does not alter the state of the machine, it only allows you to check the current state. 

The idea is that this exercise will give you the ability to read data without interactions.

The second objective here is to understand what is a **report**. Check the code and see how it is used as an output just for that single call.

The `handle_inspect` function was already modified to decode the payload and use it to route to a `listMissions` function

## User Instructions
- **Code Editing Guidelines**: Focus your modifications on the `handle_inspect` function. Maintain the rest of the application's structure to ensure it continues to operate correctly.

Suggested **Tasks**:
- Read the modifications of the `handle_inspect` function to check for a specific request and call the corresponding function.
- See that in the implementation for `handle_inspect` uses the `fetch` to create an output called **report**. This is another type of output generated by the Cartesi rollups framework.
When used inside a handle_inspect it is the default way of setting the output that the user gets when invoking the http request.
- Edit the `listMissions` function to return the list of available missions


## Required Modification
Here is how you should modify the `listMissions` function to incorporate a new route that provides a list of missions:

return a json with the structure `{ missions }`

But remember! It has to be stringified and then converted to a hex!

### Side note
Of course in a final version of this dApp we have to verify the missions by user, so it will be something like this:
```url
http://<rollup_server>/list_missions/<wallet_id>"
```
But for now no need to worry about that!
